Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.

```go
package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
```

Ответ:
``` <nil>
	false
```
```
Интерфейс это обычная структура из двух полей 

```
```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```
```
itab означает interface table и тоже является структурой, в которой хранится дополнительная информация об интерфейсе и базовом типе:
```
```go
type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    bad    int32
    unused int32
    fun    [1]uintptr // variable sized
}
```

```
по своей сути интерфейс это всего лишь набор данных о типах (интерфейса и типа переменной внутри него) и указатель на, собственно, саму переменную со статическим (конкретным) типом (поле data в iface)
 Тот объект, что мы возвращаем из функции foo() — это уже более сложная структура, в которой хранится не только информация об интерфейсе, но и информация о типе переменной, и адрес в памяти на блок, в котором лежит nil указатель. 

```

```
 пустой интерфейсс — interface{}. В исходниках Go он реализован отдельной структурой — eface (src/runtime/malloc.go):

```
```go
type iface struct {
    type eface struct {
    _type *_type
    data  unsafe.Pointer
}
}
```
```
 Легко заметить, что эта структура похожа на iface, но в ней нет таблицы интерфейса (itab). Что логично, потому что, по определению, любой статический тип удовлетворяет пустому интерфейсу. Поэтому, когда вы "заворачиваете" какую-либо переменную — явно или неявно (передавая, как аргумент или возвращая из функции, например) — в interface{}, вы на самом деле работаете с вот этой структурой.

```